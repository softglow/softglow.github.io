
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>softglow's notebook</title>
  <meta name="author" content="softglow">

  
  <meta name="description" content="There&rsquo;s an end-of-year rush on at work, involving a lot of hardcore
programming leading up to a demo day, so I don&rsquo;t have the bandwidth &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://softglow.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="softglow's notebook" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">softglow's notebook</a></h1>
  
    <h2>Dispatches from the Depths of a Super Nintendo</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:softglow.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/09/on-break/">On Break</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-09T18:46:00-05:00" pubdate data-updated="true">Dec 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>There&rsquo;s an end-of-year rush on at work, involving a lot of hardcore
programming leading up to a demo day, so I don&rsquo;t have the bandwidth left to
work hard at home until about Christmas.  Further progress and updates aren&rsquo;t
expected before then.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/14/dsp-emulators/">DSP Emulators</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-14T21:15:00-05:00" pubdate data-updated="true">Nov 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I was reading around byuu&rsquo;s forum (technically, preparing to make sure my
question regarding the accuracy of byuu&rsquo;s SMP/DSP vs. blargg&rsquo;s was in the
right sub-forum) when I came upon the answer to my question.</p>

<p>To summarize into a a perfect viral posting for social sites&hellip;</p>

<h2>TIL: 3 Amazing Facts About SNES Audio Emulators</h2>

<ol>
<li>blargg&rsquo;s DSP is 100% pure awesome.</li>
<li>byuu&rsquo;s SMP is better than blargg&rsquo;s, though.</li>
<li>byuu&rsquo;s <em>main</em> SMP only has style points over the <em>alt</em> SMP core.  E.g. it
emulates the <code>TEST</code> register which nobody uses.</li>
</ol>


<h2>So was I wasting my time?</h2>

<p>Partly.  I think extracting <code>sfc/alt/{smp,dsp}</code> is the way to go, which makes
the deep dive on the main cores mostly irrelevant, but everything I needed to
know to extract them, I still need to know to extract the alt cores.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/12/maybe-ive-been-wasting-my-time/">Maybe I&#8217;ve Been Wasting My Time?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-12T20:17:00-05:00" pubdate data-updated="true">Nov 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In higan&rsquo;s <code>sfc/alt/dsp</code> directory is the alternate SMP emulation core, used
when the accuracy profile isn&rsquo;t selected.  It apparently depends on a couple
of <a href="http://slack.net/~ant/libs/audio.html">Blargg&rsquo;s audio libraries</a> which
includes&hellip; &ldquo;snes_spc-0.9.0&rdquo;.  Of which blargg boasts:</p>

<blockquote><p>The accurate DSP passes over a hundred strenuous timing and behavior
validation tests that were also run on the SNES. As far as I know, it&rsquo;s the
first DSP emulator with cycle accuracy, properly emulating every DSP
register and memory access at the exact SPC cycle it occurs at&hellip;</p></blockquote>

<p>And of course, <em>this</em> is already written as a library, meant to be used in
another project.  No games required.</p>

<p>My only question is: if <code>snes_spc</code> is <em>that</em> accurate, why does higan not use
it in accuracy mode for its own accuracy profile?  Is byuu&rsquo;s DSP somehow more
accurate?  (I suspect so.  It&rsquo;s not like <code>snes_spc</code> is a fast-moving target,
as its first public release is also, AFAICT, its only one.)  I don&rsquo;t want to
commit one way or the other without an answer&hellip;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/07/where-the-samples-are/">Where the Samples Are</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-07T20:58:00-05:00" pubdate data-updated="true">Nov 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Looking at the <a href="http://byuu.org/higan/">higan</a> v093 source, it&rsquo;s fairly
obvious where the DSP code lives, but how does the sound escape it?</p>

<h2>Sending samples to the Interface</h2>

<p>In the <del>performance</del> accuracy profile, the process actually begins down in
<code>echo_27()</code>, implemented in <code>sfc/dsp/echo.cpp</code>.  It is there that the elusive
<code>audio.sample()</code> method is called, which is part of Audio, over in
<code>sfc/system/audio.cpp</code>.  In the case where there&rsquo;s no coprocessor, it passes
directly into <code>interface-&gt;audioSample</code>.</p>

<p>In the complicated case where there <em>is</em> a coprocessor, then the audio heads
into a DSP buffer, to be averaged in <code>audio.flush()</code> with the coprocessor&rsquo;s
buffer; the final samples are clamped to 16 bits and finally routed through
the same <code>interface-&gt;audioSample</code> there.</p>

<h2>Interface</h2>

<p>Sharp eyes will have noticed the arrow operator, indicating that <code>interface</code>
is a pointer.  It&rsquo;s a pointer to the binding of the current interface, which
is to say: it&rsquo;s a <code>Interface *interface</code> where the type is <code>struct Interface :
Emulator::Interface::Bind</code>.</p>

<p>Looking from the outside in, <code>target-ethos/bootstrap.cpp</code> creates the
binding-interface, creates and appends all the known <em>system</em> emulators to a
vector, then iterates over the vector to set each system emulator&rsquo;s binding to
the single global binding that it <em>just</em> created.</p>

<p>Although <code>audioSample</code> is virtual, I haven&rsquo;t found anything yet which actually
overrides it.</p>

<h2>audioSample &amp; dspaudio</h2>

<p>The implementation of audioSample in <code>target-ethos/interface/interface.cpp</code>
does very little:</p>

<pre><code>signed samples[] = {lsample, rsample};
dspaudio.sample(samples);
while(dspaudio.pending()) {
    dspaudio.read(samples);
    audio.sample(samples[0], samples[1]);
}
</code></pre>

<p>The <code>dspaudio</code> is a <code>nall::DSP</code> declared in <code>target-ethos/ethos.cpp</code> and
implemented in <code>nall/dsp/core.hpp</code>.  Pretty much, samples go into the DSP,
they get resampled to the output sample rate, and then those results can be
read out again.</p>

<p>The trick here is that the <code>audio</code> visible in <em>this particular scope</em> is
actually <code>AudioInterface audio</code> from <code>ruby/ruby.cpp</code>.  Platform audio drivers
live under <code>ruby/audio/*.cpp</code> and <code>AudioInterface::sample</code> passes the samples
along to whatever driver happens to be connected.</p>

<h2>tl;dr</h2>

<p>If the madness hasn&rsquo;t taken me:</p>

<ol>
<li>The system DSP produces samples and passes it into the system audio chain.</li>
<li>The system audio chain passes samples into the platform interface.</li>
<li>The platform interface pumps samples through the resampler.</li>
<li>The resulting samples are pushed into the platform audio driver.</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/04/solved-the-mystery-of-privilege/">Solved: The Mystery of Privilege</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-04T19:30:00-05:00" pubdate data-updated="true">Nov 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Just a quick note, since <code>privileged</code> is actually not a C++ keyword, the
thought <em>finally</em> crossed my mind: what if it&rsquo;s a macro?</p>

<p>One quick grep later, there was one match in <code>emulator/emulator.hpp</code> line
72-76 (for anyone who hasn&rsquo;t read the whole blog, this is the higan v093
source I&rsquo;m talking about):</p>

<pre><code>#if defined(DEBUGGER)
    #define privileged public
#else
    #define privileged private
#endif
</code></pre>

<p>Yeah, it looks like a good day to be humble about my programming ability.  It
only took me, like, a <em>month</em> to come up with that idea.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/31/brief-intermission/">Brief Intermission</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-31T21:04:00-04:00" pubdate data-updated="true">Oct 31<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>No progress is expected this week.  I&rsquo;m taking the week off to catch up on
some other things around the house.</p>

<p>I&rsquo;m disappointed, actually.  I wanted to have <em>higan</em> connected by the end of
October, not just a stupid triangle wave generator.  (Which is the easiest
waveform to program&mdash;since <code>dy/dt = C</code>, all you need is a fixed delta that
gets its sign inverted when reaching the edge of the range.)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/26/sndthread-lives/">SndThread Lives</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-26T14:09:00-04:00" pubdate data-updated="true">Oct 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I wrote that I had the thread buffer handoff working correctly.  Hah.  Ha!
HAHAHAHAHAHA!</p>

<p><em>Now</em> it works.  I got a thin, quiet, reedy whine out of it last night, and
today, I tracked down the final bug: the IO formatter was shifting the wrong
direction, thus turning a sample like <code>3560</code> into output bytes <code>6000</code> because
<code>350000 &amp; ff</code> (the implicit conversion to byte) is zero.</p>

<p><img src="/blog/images/2013/10/audacity-triangle-zero.png" width="780" height="620"></p>

<p>This started life as a triangle wave, but when I got a bad sound, I tried
&lsquo;flattening&rsquo; the peaks out to put in more sound power and make it fuller.
This did not work.  Not only was sound power unimportant, but instead of
holding the <em>peak</em> value, it holds <em>zero.</em></p>

<p>But, since this bug is clearly in the generator and the rest of the output
chain <strong>is</strong> working to suit me, I&rsquo;m going to leave it unfixed and move on to
connecting higan&rsquo;s SMP/DSP subsystem in place of my broken generator.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/24/progress-report/">Progress Report</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-24T20:02:00-04:00" pubdate data-updated="true">Oct 24<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I got the buffer passing code that I described
<a href="/blog/2013/10/20/on-qaudiooutput/">on Sunday</a> running.  It&rsquo;s important that
if you&rsquo;re not going to call <code>QIODevice::write</code> to put data into the
device&mdash;because, say, you&rsquo;re swapping in a buffer and converting it at
<code>read()</code> time because, um, you&rsquo;re just doing it wrong&mdash;that you emit the
<code>readyRead</code> and <code>bytesWritten</code> signals yourself when you swap in a buffer.
Otherwise, the audio output never gets signaled that the device is readable,
and stops output after a timeout.</p>

<p>&lt;/tangent&gt;</p>

<p>It turns out that the tone generator I&rsquo;ve connected for testing (to stand in
for higan) is broken.  Completely busted.  It produces an infinite number of
repetitions of:</p>

<pre><code>0
0
-32768
-32768
</code></pre>

<p>That is <strong>not</strong> a triangle wave.  And since no horrible howl comes out of my
speakers, either the audio output stage is also broken, or something is
detecting &ldquo;this makes no sense&rdquo; and sparing my ears.</p>

<p>Oh well.  If I&rsquo;m lucky enough, <em>maybe</em> I&rsquo;ll get to the point where I have an
SPC player using higan&rsquo;s audio engine by 2014.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/20/on-qaudiooutput/">On QAudioOutput</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-20T16:31:00-04:00" pubdate data-updated="true">Oct 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Most QT resources seem to want me to use higher-level classes like
<code>QMediaPlayer</code> or <code>QSoundEffect</code> to point at extant files or <em>possibly</em> a
<code>QAudioBuffer</code> which is already filled with a <code>QByteArray</code>.  There&rsquo;s really
not much out there about <strong>synthesizing</strong> audio and playing it straight
through a <code>QAudioDevice</code>.</p>

<p>The latter may operate in push mode or pull mode; the docs will tell you as
much.  What may be less obvious is <em>how</em> those modes are chosen.  It&rsquo;s simply
your choice of overloaded method:</p>

<pre><code>QIODevice QAudioOutput::start(); // push mode
void QAudioOutput::start(QIODevice *dev); // pull mode
</code></pre>

<p>Looking over the pre-made classes that implement <code>QIODevice</code>, I notice that
they love to tell you when <em>data is ready to read</em> but not <em>when data may be
written.</em>  And in <strong>both</strong> modes, the <code>QAudioOutput</code> is doing the reading and
your application needs to know, somehow, when it should write.</p>

<p>So, I implemented my own <code>QIODevice</code> around my own buffer type.  The class
actually holds a pair of buffers, one being written by the generator thread
and one being read by <code>QAudioOutput</code>.  When both are finished, the buffers are
swapped.  Whenever the output calls <code>read</code>, I format data from the app&rsquo;s
buffer into bytes, directly into the output pointer.</p>

<p>And actually, nobody calls write.  The generator can be connected directly to
the app buffer, which provides its own <code>append()</code> method that consumes
(potentially many) <code>snd_sample_t</code>s.</p>

<p>There are a pair of signals and slots each side uses to communicate about
their shared buffer:</p>

<pre><code>class SndIO : public QIODevice {
    Q_OBJECT
    ...
public slots:
    void writeComplete(SndBuf *buf);
signals:
    void readyWrite(SndBuf *buf);
    void emptied();
    void underrun();
}
class SndThread : public QObject {
    Q_OBJECT
    ...
public slots:
    void start(SndBuf *buf);
signals:
    void finished(SndBuf *buf);
}
</code></pre>

<p>The main thread then connects <code>SndIO::readyWrite</code> to <code>SndThread::start</code> and
<code>SndThread::finished</code> to <code>SndIO::writeComplete</code>.  The SndBuf itself isn&rsquo;t used
simultaneously by multiple threads, because the IO won&rsquo;t touch it until the
Thread has signaled that it has finished filling it.</p>

<p>This produces a four-state system, starting with &ldquo;both buffers empty&rdquo; before
the main thread wires the objects and initiates the first fill on the IO.</p>

<pre><code>1. empty/empty
2. empty/filling
3. draining/filling
4. draining/full
</code></pre>

<p>When state 2 emits finished, state 3 begins; emission of emptied there returns
to state 2, otherwise, finished happens again and state 4 is entered.  From
state 4, the only move is back to state 3 when the emptied signal is emitted.
After the initialization period (once state 3 has been entered for the first
time), it&rsquo;s possible for state 2 to receive another read from the
<code>QAudioOutput</code>; this emits the underrun signal without changing state.</p>

<p>This is a actually a slightly-more-complex version of the producer/consumer
problem.  Instead of a single producer and consumer directly communicating,
there is an intervening <code>QIODevice</code> carrying data across threads, consuming
the generator&rsquo;s output, then marshaling and producing it for the output to
consume.</p>

<p>I&rsquo;m also effectively using signals and slots to let the event loop block the
producer when it gets too far ahead.  When that happens, no &ldquo;produce more&rdquo;
signal is delivered until the output can catch up.</p>

<p>All that said, this setup <em>compiles</em> but I haven&rsquo;t finished wrapping a test
program around it yet.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/13/libco-sync-via-calling/">Libco: Sync via Calling Without Endless Recursion</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-13T18:37:00-04:00" pubdate data-updated="true">Oct 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Continuing our discussion of <a href="http://byuu.org/higan/">higan</a> from
<a href="/blog/2013/10/12/synchronization-in-higan-smp-slash-dsp/">yesterday</a>, let’s
take a moment to look deeper into the abyss.</p>

<h2>SMP::Threaded</h2>

<p>This isn’t pthreads or anything; it’s <code>libco</code> threads.  libco appears to be
named for <em>coroutines</em> and focuses on user-space or “green” threading rather
than OS threads.  In fact, libco ships with generic implementations for
Windows using fibers, and for GCC using a GNU Pth inspired setjmp/longjmp
technique.  Including a little trickery with <code>sigaltstack</code> to actually set up
the alternate allocation as a stack.</p>

<p>AFAICT, everything is set up with <code>Threaded=true</code> and the emulator would
actually break if it were otherwise.  Everything would keep calling
<code>thing.enter()</code> until eventually the emulator ran out of stack space and
crashed.</p>

<h2>Tracing cpu.add_clocks</h2>

<p>From our previous post, we know that <code>add_clocks</code> is called when the CPU needs
to perform bus operations, so our adventure today really begins with the
implementation of this function, inside <code>sfc/cpu/timing/timing.cpp</code>.</p>

<p>The function starts off by unlocking IRQs, then computing a number of ticks
(which is just <code>clocks/2</code>), and calling <code>tick()</code> for each tick.  tick itself
merely updates the horizontal and vertical counters, essentially keeping track
of where the raster scanout is happening in the PPU.  (It was hard to find;
it’s in <code>sfc/ppu/counter/counter-inline.hpp</code> which <code>CPU</code> inherits, and it’s
loaded in via <code>sfc/sfc.hpp</code> and <code>sfc/cpu/cpu.cpp</code>.)</p>

<p>After ticking, the step function is called, which reduces the clock cycle of
each active subsystem (SMP, PPU, and any coprocessors present) before
synchronizing the controllers.  Next, the joysticks are polled every 256
clocks, DRAM refreshed when needed (at a cost of 40 more cycles), and when
<code>DEBUGGER</code> is defined, all the other chips are fully synchronized again.</p>

<h2>clocks, then&hellip;</h2>

<p>It appears that the clocks are tracking “cycles ahead/behind in emulation:”
where “0” means perfectly synchronized with the current CPU state, negative
means the given part is behind, and of course, positive means ahead.  When the
CPU runs, it reduces the <code>smp.clock</code> and <code>dsp.clock</code> values, and when the SMP
gets a chance to run, it increases its <code>smp.clock</code> value.  When it crosses 0,
then the SMP is synchronized, and if the synchronization mode calls for it,
emulation will sync up the DSP (by the same mechanism: the SMP has been
decrementing clocks, so when sync happens, the DSP increments its clock
value), then return to the CPU.</p>

<h2>Synchronization points</h2>

<p>The SMP is actually invoked to re-sync itself with the main CPU whenever the
chips need to communicate (i.e. if the CPU wants to read or write the SMP IO
ports), on each new scanline (when tick brings the hcounter back to 0), and on
a debug build, every time the CPU is updated.  I presume that last one keeps
everything in perfect sync from the debugger’s point of view.</p>

<p>The CPU calls to <code>synchronize_smp()</code> in <code>sfc/cpu/mmio/mmio.cpp</code> (for port
access) and <code>sfc/cpu/timing/timing.cpp</code> for the other cases.</p>

<p>Meanwhile, the SMP subsystem returns the favor by calling <code>synchronize_cpu</code>
from <code>SMP::add_clocks</code> in <code>sfc/smp/timing.cpp</code>—either every sample produced in
debug builds, or after 24 samples—and from <code>sfc/smp/memory.cpp</code> on port IO.</p>

<h2>Wait, your post’s title was libco, wtf dude?</h2>

<p>The synchronization points listed above bring us back to libco.  If the CPU
calls <em>into</em> the SMP to synchronize it, and it calls <em>into</em> the CPU afterward,
then the call stack is going to get infinitely deep.  In this contrived case
where I ignore a whole lot of stuff (both the other hardware, and the rest of
the call stack involved in actually emulating the SMP/CPU between calls to
enter), the stack would get filled up looking like:</p>

<pre><code>inside smp.enter
inside cpu.enter
inside smp.enter
inside cpu.enter
inside smp.enter
inside cpu.enter
…
</code></pre>

<p>When it eventually exhausted the stack limit, the process would receive a
segfault and most likely, unceremoniously die after emulating a finite number
of cycles.  That’s where <code>libco</code> comes in.</p>

<p>Because <code>Threaded</code> is always true, direct calls aren’t made; they’re sent
through <code>co_switch</code> instead, which does some trickery to swap out the “thread”
that is running the active processor, and replace it with the thread of the
target.</p>

<p>Instead of pushing a frame onto the <em>current</em> stack and starting the target
function anew, <code>libco</code> allows for suspending the current thread+stack
entirely, (re)loading the other one, and resuming it—exactly as if <em>it</em> had
called and returned, except this appears in C++ as a call and call.</p>

<p>This gives byuu a lot of freedom to just call <code>synchronize_thing</code> all over the
place without worrying, because it’s not consuming a limited amount of call
depth to do so.  But it makes it a little harder to just yank out the code and
call it from a QT program.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/12/09/on-break/">On Break</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/14/dsp-emulators/">DSP Emulators</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/12/maybe-ive-been-wasting-my-time/">Maybe I&#8217;ve Been Wasting My Time?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/07/where-the-samples-are/">Where the Samples Are</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/04/solved-the-mystery-of-privilege/">Solved: The Mystery of Privilege</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - softglow -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
